...

idea: cambiare stato n volte carattere per carattere è equivalente a ricevere un input la relativa stringa di lunghezza n e
saltare direttamente allo stato n

...

TEOREMA 1
Un linguaggio L(R) è non vuoto se e solo se il riconoscitore R accetta una stringa x di lunghezza Lx minore del numero di stati N
dell’automa

in parole povere ...

Il teorema afferma che un linguaggio accettato da un automa (chiamato  L(R)) non è vuoto (cioè contiene almeno una stringa), se
e solo se l’automa stesso può accettare una stringa di lunghezza minore del numero dei suoi stati.

In altre parole, se l’automa ha N stati, il teorema ci dice che se esso accetta qualche stringa, allora esiste una stringa con una 
lunghezza inferiore a N che l’automa può accettare. Se non esistesse una stringa così corta, il linguaggio L(R) sarebbe vuoto,
ovvero l’automa non accetterebbe alcuna stringa -> assurdo

Quindi, il teorema ci dà una condizione chiara per verificare se l’automa accetta qualcosa: basta controllare se esiste una stringa
più corta del numero di stati

TEOREMA 2
Un linguaggio L(R) è infinito se e solo se il riconoscitore R accetta una stringa x di lunghezza N <= Lx < 2N, con N numero di
stati dell’automa.

CONSEGUENZE
In conseguenza di questi due teoremi, decidere se un linguaggio regolare sia vuoto o infinito è un problema risolubile!
    • nel primo caso, basta esaminare se esiste una stringa accettata di lunghezza minore di N
    • nel secondo caso, basta verificare se esiste una stringa accettata fra quelle di lunghezza compresa fra N (incluso) e 2N (escluso).
    • Come si vedrà più avanti, tali proprietà sono decidibili anche nel Tipo 2, mentre non lo sono nel Tipo 1 (e 0).

GENERATORI
Riconsideriamo l'automa riconoscitore precedente, Se sostituiamo alla parola “accettare” la parola “generare” otteniamo un nuovo
insieme di affermazioni:
    • nello stato I l’automa genera a e si porta in A (per poi proseguire)
    • nello stato A l’automa genera a e si riporta in A (per poi proseguire)
    • nello stato A l’automa genera b e si ferma (F è uno stato finale)
NB: Queste frasi sono interpretabili come produzioni di una qualche grammatica (regolare)!

Si può definire un mapping:
    - stati         ->simboli non terminali
    - transizioni   -> produzioni
    - scopo         -> uno stato particolare

CONCLUSIONE
Si può dunque automatizzare la costruzione di un RSF a partire dalla grammatica, o, viceversa, risalire a una grammatica dato un RSF.

...
Non sempre però le cose vanno così lisce:
    - l’analisi bottom-up può non essere immediata in presenza di più stati finali, che corrisponderebbero a scopi multipli di G2,
      o in presenza di archi entranti nello stato iniziale
    - l’analisi top-down richiede attenzione se vi sono archi uscenti da stati finali.


--- AUTOMI NON DETERMINISTICI
almeno in uno stato, con lo stesso ingresso, ci sono due o più alternative.

    -> ALMENO UNA ... se ne vuole ESATTAMENTE una

Esempi prolog come linguaggio che supporta il non determinismo

--- TEOREMA DEL MARTELLOOOOOOO!!!!
nel tipo 3 il non determinismo non ci piace. In parole povere è sempre possibile trovare un automa deterministico equivalente alla sua 
versione non deterministica.

idea: sostituzione!

...

gli stati finali sono quelli con la F dentro

è estremamente probabile che l'automa cosi definito non sia minimo -> minimizziamolo

il ciclo causava il bivio modena-modena -> colpevole
    -> ci siamo liberati del non determinismo spostando un ciclo da uno stato a quello dopo
    -> ricorda: il non determinismo è sempre causato dal dover decidere troppo presto
        -> soluzione: guadagnare tempo